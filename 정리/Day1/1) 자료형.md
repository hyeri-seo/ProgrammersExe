# 1) `int` (정수)

- 용도: 소수점 없는 정수값
- 크기/범위: 32비트, `-2,147,483,648 ~ 2,147,483,647`
- 기본값(필드): `0`
- 박싱 타입: `Integer`
- 주의: 오버플로우 발생 시 에러 안 나고 <b>순환됨</b>

```java
int a = 2000000000;
int b = a + a; // 4,000,000,000 - 4,294,967,296(=2^32) = -294,967,296
```

=> 정확하게 계산하기 위해서는 long을 사용해야 
  
- 파싱/출력

```java
int n = Integer.parseInt("123");
System.out.println(Integer.toString(n));
```
---

# 2) `long` (정수)

- 용도: `int`(32비트)로 모자랄 수 있는 큰 정수 저장
- 크기/범위: 64비트, `-9,223,372,036,854,775,808L ~ 9,223,372,036,854,775,807L`
- 리터럴 표기: 끝에 `L` 또는 `l` 붙이기
- 기본값(필드): `0L`
- 래퍼 타입: `Long` (박싱/언박싱 주의)
- 언제 쓰나?
  - 합/곱/누적 합이 `int` 범위를 넘을 가능성이 있을 때
  - 예: 누적 합, 조합 수, 지수적 증가, 큰 인덱스/카운트
  - 시간/타임스탬프(ms/ns), 해시/ID, 비트마스크(64비트) 등
- 파싱/출력

```java
long v = Long.parseLong("12345678900");
System.out.println(Long.toString(v));
System.out.printf("%d%n", v);
```

- 비교/정렬

```java
int cmp = Long.compare(a, b);  // -1, 0, 1
boolean eq = Objects.equals(Long.valueOf(a), Long.valueOf(b));  // 박싱 비교
```

- 산술 & 캐스팅
  - `int * int`는 int 연산 -> 곱의 중간값이 터질 수 있음. 최소 하나를 미리 `long`으로 캐스팅

 ```java
int n = 100,000, m = 100,000;
long areaWrong = n * m;        // int에서 오버플로우 후 long 저장 (잘못)
long areaRight = (long)n * m;  // long 연산으로 안전
```

  - 나눗셈은 정수 나눗셈 -> 필요시 실수 변환

```java
double avg = (double)sum / count;
```

- 비트 연산 (64비트 마스크에 유리)

```java
long mask = 1L << 42;  // 반드시 1L (long 리터럴) 사용
long and = x & mask;
long or = x | mask;
long xor = x ^ mask;
long not = ~x;
```

- 성능 & 메모리
  - `long`은 `int`보다 메모리 2배. 그래도 보통 코테에서 문제 없음
  - 박싱(`Long`)은 자동 객체 생성 -> <b>컬렉션에 대량 넣고 빼면 비용이 많이 듦.</b> 가능하면 원시형 배열/원시 연산 사용
- 코딩테스트에서 흔한 패턴
  1. 누적합/곱은 `long`으로
   ```java
   long sum = 0;
   for (int x : arr) sum += x;
   ```
  2. 조합/경로 수(큰 값) 계산
   ```java
   long ways = 1;
   for (int i = 1; i <= n; i++) {
     ways = Math.multiplyExact(ways, i);
   }
   ```

  3. 입력 파싱 (BufferedReader + StringTokenizer)

   ```java
   StringTokenzier st = new StringTokenizer(br.readLine());
   long a = Long.parseLong(st.nextToken());
   long b = Long.parseLong(st.nextToken());
   ```

  4. 안전 곱셈 (중간 오버플로우 방지)

  ```java
  static boolean willMulOverflow(long x, long y) {
    if (x == 0 || y == 0) return false;
    if (x > 0 ? y > Long.MAX_VALUE / x : y > Long.MIN_VALUE / x) return true;
    if (x < 0 ? y > Long.MIN_VALUE / x : y < Long.MIN_VALUE / x) return true;
    return false;
  }
  ```

- 자주 나오는 함정 체크리스트
  - 곱/합이 int 범위 넘지 않는지 -> 넘으면 `long`으로 승격
  - `L` 안 붙여서 시프트/곱에서 터지지 않는지
  - `String` -> 숫자 파싱은 `Long.parseLong`인지
  - `Long` 비교를 `==`로 하지 않았는지 (`equals` or `compare`)
  - 지나친 `flush()` 호출/박싱 남발로 성능 떨어지지 않는지
